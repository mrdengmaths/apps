<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distance vs. Time Graph Explorer</title>
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Custom Stylesheet -->
    <style>
        @keyframes pop-in {
          0% { transform: scale(0.5) translateY(20px); opacity: 0; }
          80% { transform: scale(1.1) translateY(0px); opacity: 1; }
          100% { transform: scale(1) translateY(0px); opacity: 1; }
        }
        .score-animation {
          animation: pop-in 0.5s ease-out forwards;
        }
        @keyframes pingOnce {
          0% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.8); opacity: 0.7; }
          100% { transform: scale(2.5); opacity: 0; }
        }
        .animate-pingOnce {
          animation-name: pingOnce;
          animation-timing-function: ease-out;
        }
        /* Additional global styles */
        body {
            font-family: Inter, sans-serif;
        }
        .car-cursor {
            /* Updated car icon with smoke and a longer, brighter headlight. */
            cursor: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZHRoPSIyNCIgdmlld0JveD0iLTUgMCA0MiAyNCI+PHBhdGggZD0iTS0xLDE2IEMtNCwxNiAtNSwxNCAtNSwxMiIgc3Ryb2tlPSJncmV5IiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiIHN0cm9rZS1vcGFjaXR5PSIwLjciLz48cGF0aCBkPSJNMjgsMTcgTDI4LDE0IEMyOCwxMiAyNiwxMiAyNiwxMiBMMjIsMTIgTDE5LDggTDgsOCBMNSwxMiBMMCwxMiBMMCwxNyBaIiBmaWxsPSIjZWY0NDQ0IiBzdHJva2U9IiMxMTEiIHN0cm9rZS1redWlkdGg9IjEuNSIvPjxjaXJjbGUgY3g9IjciIGN5PSIxNyIgcj0iNCIgZmlsbD0iIzIyMiIgLz48Y2lyY2xlIGN4PSIyMyIgY3k9IjE3IiByPSI0IiBmaWxsPSIjMjIyIiAvPjxwb2x5Z29uIHBvaW50cz0iMjgsMTMgMzUsMTAgMzUsMTYiIGZpbGw9IiNmZmZmOTkiIGZpbGwtb3BhY2l0eT0iMC45Ii8+PC9zdmc+') 16 12, crosshair;
        }
    </style>
</head>
<body class="bg-slate-100">
    <div id="root"></div>
    <!-- Custom React Script -->
    <script type="text/babel">
        // --- Constants ---
        const TARGET_MAX_TIME = 30;
        const MIN_TURNS = 3;
        const MAX_TURNS = 7;
        const SVG_WIDTH = 800;
        const SVG_HEIGHT = 500;
        const MARGIN = { top: 60, right: 50, bottom: 70, left: 60 };
        const GRAPH_WIDTH = SVG_WIDTH - MARGIN.left - MARGIN.right;
        const GRAPH_HEIGHT = SVG_HEIGHT - MARGIN.top - MARGIN.bottom;
        const HOME_DEST_BAR_HEIGHT = 50;
        const COUNTDOWN_DURATION = 3;
        const STATIONARY_RECORD_INTERVAL = 0.1;

        // --- Helper Functions ---
        const calculateSpeed = (p1, p2) => {
          if (!p1 || !p2 || p2.time === p1.time) return 0;
          return ((p2.distance - p1.distance) / (p2.time - p1.time)).toFixed(2);
        };

        const getGradientExplanation = (speed) => {
          const numericSpeed = parseFloat(speed);
          if (numericSpeed > 0.01) return `Positive gradient (${speed} m/s): Moving away from Home.`;
          if (numericSpeed < -0.01) return `Negative gradient (${speed} m/s): Moving towards Home.`;
          return `Zero gradient (${speed} m/s): Stationary.`;
        };

        const interpolateDistance = (data, time) => {
            if (!data || data.length === 0) return null;
            const exactMatch = data.find(p => p.time === time);
            if (exactMatch) return exactMatch.distance;
            const times = data.map(d => d.time);
            const index = d3.bisectLeft(times, time);
            if (index === 0) return data[0]?.distance ?? null;
            if (index >= data.length) return data[data.length - 1]?.distance ?? null;
            const p0 = data[index - 1];
            const p1 = data[index];
            if (!p0) return p1?.distance ?? null;
            if (!p1) return p0?.distance ?? null;
            if (p1.time === p0.time) return p0.distance;
            const tRatio = (time - p0.time) / (p1.time - p0.time);
            if (isNaN(tRatio) || !isFinite(tRatio)) return p0.distance;
            return p0.distance + tRatio * (p1.distance - p0.distance);
        };

        // --- Icon Replacements (Unicode/Text) ---
        const PlayIcon = () => '►';
        const RetryIcon = () => '↺';
        const NewGraphIcon = () => '»';
        const HelpIcon = () => '?';
        const ChevronLeftIcon = () => '«';
        const ChevronRightIcon = () => '»';
        const PauseIcon = () => '❚❚';


        // --- App Component ---
        const App = () => {
          const [gameState, setGameState] = React.useState('idle');
          const [targetGraphData, setTargetGraphData] = React.useState([]);
          const [userGraphData, setUserGraphData] = React.useState([]);
          const [currentMaxDistance, setCurrentMaxDistance] = React.useState(100);
          const [stopwatchTime, setStopwatchTime] = React.useState(0);
          const [similarityScore, setSimilarityScore] = React.useState(0);
          const [feedbackMessage, setFeedbackMessage] = React.useState('');
          const [performanceMetrics, setPerformanceMetrics] = React.useState(null);
          const [bestScore, setBestScore] = React.useState(() => {
            return localStorage.getItem('bestScore') || 0;
          });
          const [countdownValue, setCountdownValue] = React.useState(COUNTDOWN_DURATION);
          const [showTutorial, setShowTutorial] = React.useState(false);
          const [timelineValue, setTimelineValue] = React.useState(0);
          const [tooltip, setTooltip] = React.useState(null);
          const [playSuccessAnimation, setPlaySuccessAnimation] = React.useState(false);
          const [currentBarDirection, setCurrentBarDirection] = React.useState(null);

          const svgRef = React.useRef(null);
          const homeDestBarRef = React.useRef(null);
          const requestRef = React.useRef(null);
          const stopwatchStartRef = React.useRef(null);
          const lastCursorPositionRef = React.useRef({ x: 0, distance: 0 });
          
          const generateTargetGraph = React.useCallback(() => {
            let points = [{ time: 0, distance: 0, label: 'Start' }];
            let lastTime = 0;
            let lastDistance = 0;
            const graphSpecificMaxDistance = Math.floor(Math.random() * 101) + 50;
            setCurrentMaxDistance(graphSpecificMaxDistance);
            const numSegments = Math.floor(Math.random() * (MAX_TURNS - MIN_TURNS + 1)) + (MIN_TURNS + 1);
            let hasHorizontalSegment = false;
            const horizontalSegmentIndex = numSegments > 2 ? Math.floor(Math.random() * (numSegments - 2)) + 1 : -1;

            for (let i = 0; i < numSegments; i++) {
              let newTime, newDistance;
              const remainingTime = TARGET_MAX_TIME - lastTime;
              const timeStepDenominator = (numSegments - i);
              let timeStep = remainingTime / (timeStepDenominator > 0 ? timeStepDenominator : 1);
              if (i === horizontalSegmentIndex) {
                timeStep = Math.max(timeStep * 0.3, 2);
                timeStep = Math.min(timeStep, remainingTime * 0.5);
              }
              newTime = lastTime + timeStep * (0.6 + Math.random() * 0.4);
              newTime = Math.min(newTime, TARGET_MAX_TIME);
              if (i === numSegments - 1 && newTime < TARGET_MAX_TIME) newTime = TARGET_MAX_TIME;
              if (i === horizontalSegmentIndex) {
                newDistance = lastDistance;
                hasHorizontalSegment = true;
              } else {
                newDistance = Math.random() * graphSpecificMaxDistance;
              }
              if (i !== horizontalSegmentIndex && newTime - lastTime < 1.0 && Math.abs(newDistance - lastDistance) > graphSpecificMaxDistance / 1.2) {
                newDistance = lastDistance + (Math.random() - 0.5) * (graphSpecificMaxDistance / 2.5);
              }
              newDistance = Math.max(0, Math.min(graphSpecificMaxDistance, newDistance));
              if (newTime > lastTime + 0.05) {
                points.push({ time: newTime, distance: newDistance, label: `Pt ${i + 1}` });
                lastTime = newTime;
                lastDistance = newDistance;
              } else if (i === numSegments - 1 && points.length > 1) {
                points[points.length - 1].time = TARGET_MAX_TIME;
                points[points.length - 1].distance = newDistance;
              }
            }
            if (!hasHorizontalSegment && points.length > 3) {
              const idxToMakeHorizontal = Math.floor(points.length / 2);
              if (points[idxToMakeHorizontal + 1] && points[idxToMakeHorizontal]) {
                points[idxToMakeHorizontal + 1].distance = points[idxToMakeHorizontal].distance;
                if (points[idxToMakeHorizontal + 1].time <= points[idxToMakeHorizontal].time + 0.5) {
                  points[idxToMakeHorizontal + 1].time = points[idxToMakeHorizontal].time + Math.max(1, (TARGET_MAX_TIME - points[idxToMakeHorizontal].time) * 0.1);
                }
              }
            }
            points = points.filter((point, index, self) => index === self.findIndex((p) => p.time === point.time)).sort((a, b) => a.time - b.time);
            if (points.length > 0 && points[points.length - 1].time < TARGET_MAX_TIME) {
              const finalDistance = Math.random() * graphSpecificMaxDistance;
              if (TARGET_MAX_TIME - points[points.length - 1].time > 0.1) {
                points.push({ time: TARGET_MAX_TIME, distance: finalDistance, label: 'End' });
              } else if (points.length > 0) {
                points[points.length - 1].time = TARGET_MAX_TIME;
                points[points.length - 1].label = 'End';
              }
            } else if (points.length > 0 && points[points.length - 1].time > TARGET_MAX_TIME) {
              points[points.length - 1].time = TARGET_MAX_TIME;
              points[points.length - 1].label = 'End';
            }
            if (points.length > 0) points[0].label = 'Start';
            if (points.length > 1 && points[points.length - 1].time === TARGET_MAX_TIME) points[points.length - 1].label = 'End';
            const processedPoints = points.map((p, i) => {
              if (i === 0) return { ...p, speed: 0 };
              const speed = calculateSpeed(points[i - 1], p);
              return { ...p, speed: parseFloat(speed) };
            });
            setTargetGraphData(processedPoints);
            setUserGraphData([]);
            setTimelineValue(0);
          }, []);

          const calculatePerformance = React.useCallback(() => {
            if (!userGraphData || userGraphData.length < 2 || !targetGraphData || targetGraphData.length < 2) {
              setSimilarityScore(0);
              setFeedbackMessage("Not enough data. Trace longer!");
              setPerformanceMetrics(null);
              return;
            }
            let sumSqDiff = 0;
            let count = 0;
            const timeStep = 0.1;
            const maxCompareTime = Math.min(userGraphData[userGraphData.length - 1]?.time || 0, TARGET_MAX_TIME);
            for (let t = 0; t <= maxCompareTime; t += timeStep) {
              const targetDist = interpolateDistance(targetGraphData, t);
              const userDist = interpolateDistance(userGraphData, t);
              if (targetDist !== null && userDist !== null) {
                sumSqDiff += Math.pow(targetDist - userDist, 2);
                count++;
              }
            }
            if (count === 0) {
              setSimilarityScore(0);
              setFeedbackMessage("Could not compare.");
              setPerformanceMetrics(null);
              return;
            }
            const meanSqDiff = sumSqDiff / count;
            const normalizedError = Math.sqrt(meanSqDiff) / currentMaxDistance;
            // Stricter similarity score calculation
            let score = Math.max(0, 100 * (1 - normalizedError * 1.5));
            score = Math.round(score);
            
            if(score > bestScore) {
                setBestScore(score);
                localStorage.setItem('bestScore', score);
            }
            
            setSimilarityScore(score);
            setPerformanceMetrics({
                user: {
                    maxDist: Math.max(...userGraphData.map(p => p.distance)).toFixed(1),
                    time: userGraphData[userGraphData.length-1].time.toFixed(1)
                },
                target: {
                    maxDist: Math.max(...targetGraphData.map(p => p.distance)).toFixed(1),
                    time: TARGET_MAX_TIME
                }
            });

            if (score >= 95) setFeedbackMessage("Incredible! A perfect match!");
            else if (score >= 85) setFeedbackMessage("Excellent Trace!");
            else if (score >= 70) setFeedbackMessage("Great job! Very close!");
            else if (score >= 50) setFeedbackMessage("Good effort! Keep practicing!");
            else setFeedbackMessage("Keep practicing to improve your score!");
          }, [userGraphData, targetGraphData, currentMaxDistance, bestScore]);

          const handleStopRecording = React.useCallback(() => {
            if (requestRef.current) {
              cancelAnimationFrame(requestRef.current);
              requestRef.current = null;
            }
            if (gameState === 'recording') {
              setGameState('analysis');
              calculatePerformance();
              setPlaySuccessAnimation(true);
            }
          }, [gameState, calculatePerformance]);

          const updateGame = React.useCallback(() => {
            if (stopwatchStartRef.current === null) return;
            const elapsed = (Date.now() - stopwatchStartRef.current) / 1000;
            setStopwatchTime(elapsed);
            if (homeDestBarRef.current) {
              const barWidth = homeDestBarRef.current.offsetWidth;
              if (barWidth > 0) {
                const lastKnownDistance = lastCursorPositionRef.current.distance;
                setUserGraphData(prevData => {
                  if (prevData.length === 0 || (elapsed - prevData[prevData.length - 1].time >= STATIONARY_RECORD_INTERVAL)) {
                    const lastPoint = prevData[prevData.length - 1];
                    if (!lastPoint || elapsed - lastPoint.time > 0.01 || Math.abs(lastKnownDistance - lastPoint.distance) > 0.001 * currentMaxDistance) {
                      return [...prevData, { time: elapsed, distance: lastKnownDistance }];
                    }
                  }
                  return prevData;
                });
              }
            }
            if (elapsed < TARGET_MAX_TIME) {
              requestRef.current = requestAnimationFrame(updateGame);
            } else {
              handleStopRecording();
            }
          }, [currentMaxDistance, handleStopRecording]);

          const handleStart = () => {
            setGameState('countdown');
            setCountdownValue(COUNTDOWN_DURATION);
            setUserGraphData([]);
            setStopwatchTime(0);
            setTimelineValue(0);
            setPlaySuccessAnimation(false);
            setPerformanceMetrics(null);
          };

          const handleMouseMoveOnBar = (event) => {
            if (gameState !== 'recording' || !homeDestBarRef.current) return;
            const barRect = homeDestBarRef.current.getBoundingClientRect();
            const cursorX = event.clientX;
            let relativeX = cursorX - barRect.left;
            relativeX = Math.max(0, Math.min(relativeX, barRect.width));
            const currentDistance = (relativeX / barRect.width) * currentMaxDistance;
            const elapsedTime = (Date.now() - stopwatchStartRef.current) / 1000;
            lastCursorPositionRef.current = { x: relativeX, distance: currentDistance };
            if (elapsedTime > TARGET_MAX_TIME) {
              handleStopRecording();
              return;
            }
            setUserGraphData(prevData => {
              const lastPoint = prevData[prevData.length - 1];
              if (!lastPoint || elapsedTime - lastPoint.time > 0.01) {
                return [...prevData, { time: elapsedTime, distance: currentDistance }];
              } else if (lastPoint && Math.abs(lastPoint.distance - currentDistance) > 0.001 * currentMaxDistance) {
                const newData = [...prevData];
                newData[newData.length - 1] = { ...lastPoint, distance: currentDistance };
                return newData;
              }
              return prevData;
            });
            if (Math.abs(currentDistance - currentMaxDistance) < (0.01 * currentMaxDistance) && relativeX / barRect.width > 0.98) {
              handleStopRecording();
            }
          };
          
          const handleRetry = () => {
            setGameState('idle');
            setUserGraphData([]);
            setStopwatchTime(0);
            setSimilarityScore(0);
            setFeedbackMessage('');
            setTimelineValue(0);
            setPlaySuccessAnimation(false);
            setPerformanceMetrics(null);
          };

          const handleNewGraph = () => {
            generateTargetGraph();
            handleRetry();
          };
          
          const toggleTutorial = () => setShowTutorial(!showTutorial);

          React.useEffect(() => { generateTargetGraph(); }, [generateTargetGraph]);

          React.useEffect(() => {
            const svg = d3.select(svgRef.current);
            svg.selectAll("*").remove();
            const xScale = d3.scaleLinear().domain([0, TARGET_MAX_TIME]).range([0, GRAPH_WIDTH]);
            const yScale = d3.scaleLinear().domain([0, currentMaxDistance]).range([GRAPH_HEIGHT, 0]);
            const g = svg.append("g").attr("transform", `translate(${MARGIN.left},${MARGIN.top})`);
            g.append("g").attr("transform", `translate(0,${GRAPH_HEIGHT})`).call(d3.axisBottom(xScale).ticks(TARGET_MAX_TIME / 5))
              .append("text").attr("fill", "currentColor").attr("x", GRAPH_WIDTH / 2).attr("y", 35)
              .attr("text-anchor", "middle").attr("font-size", "14px").attr("class", "font-medium").text("Time (s)");
            g.append("g").call(d3.axisLeft(yScale).ticks(currentMaxDistance / 20))
              .append("text").attr("fill", "currentColor").attr("transform", "rotate(-90)")
              .attr("x", -GRAPH_HEIGHT / 2).attr("y", -45).attr("font-size", "14px")
              .attr("text-anchor", "middle").attr("class", "font-medium").text("Distance (m)");
            const lineGenerator = d3.line().x(d => xScale(d.time)).y(d => yScale(d.distance)).defined(d => d.time != null && d.distance != null && !isNaN(d.time) && !isNaN(d.distance));
            if (targetGraphData && targetGraphData.length > 0) {
              g.append("path").datum(targetGraphData.filter(d => d.time <= TARGET_MAX_TIME)).attr("fill", "none").attr("stroke", "hsl(210, 70%, 60%)").attr("stroke-width", 2.5).attr("d", lineGenerator);
              if (gameState === 'recording') {
                let activeSegment = null;
                for (let i = 0; i < targetGraphData.length - 1; i++) {
                  if (stopwatchTime >= targetGraphData[i].time && stopwatchTime < targetGraphData[i + 1].time) {
                    activeSegment = [targetGraphData[i], targetGraphData[i + 1]];
                    break;
                  }
                }
                if (!activeSegment && targetGraphData.length > 1 && stopwatchTime >= targetGraphData[targetGraphData.length - 1].time) {
                  activeSegment = [targetGraphData[targetGraphData.length - 2], targetGraphData[targetGraphData.length - 1]];
                }
                if (activeSegment) {
                  g.append("path").datum(activeSegment).attr("fill", "none").attr("stroke", "blue").attr("stroke-width", 4.5).attr("d", lineGenerator);
                }
              }
              g.selectAll(".target-point").data(targetGraphData.filter(d => d.time <= TARGET_MAX_TIME)).enter().append("circle").attr("class", "target-point").attr("cx", d => xScale(d.time)).attr("cy", d => yScale(d.distance)).attr("r", 4).attr("fill", "blue");
              if (gameState === 'analysis') {
                for (let i = 0; i < targetGraphData.length - 1; i++) {
                  if (targetGraphData[i + 1].time > TARGET_MAX_TIME) continue;
                  const segment = [targetGraphData[i], targetGraphData[i + 1]];
                  g.append("path").datum(segment).attr("fill", "none").attr("stroke", "transparent").attr("stroke-width", 15).attr("d", lineGenerator).style("cursor", "help")
                    .on("mouseover", (event) => { setTooltip({ x: event.clientX, y: event.clientY, content: getGradientExplanation(segment[1].speed), segmentIndex: i }); })
                    .on("mouseout", () => setTooltip(null));
                }
              }
            }
            if (userGraphData && userGraphData.length > 0) {
              g.append("path").datum(userGraphData.filter(d => d.time <= TARGET_MAX_TIME)).attr("fill", "none").attr("stroke", "red").attr("stroke-width", 2.5).attr("d", lineGenerator);
            }
            if (gameState === 'analysis' && userGraphData && userGraphData.length > 1 && targetGraphData && targetGraphData.length > 1) {
              const areaGenerator = d3.area().x(d => xScale(d.time)).y0(d => yScale(d.targetDistance)).y1(d => yScale(d.userDistance)).defined(

